// =============================================================================
// MVU Runtime
// =============================================================================
// Model-View-Update as a specialization of the Automaton kernel.
//
// MVU extends the core automaton with:
// - A View function: State → Rendered output
// - Subscriptions: State → external event sources
//
// The runtime executes the loop: dispatch event → transition → view → effects.
//
// Structurally, MVU is the shared AutomatonRuntime with:
// - Observer = render the new state into a view
// - Interpreter = execute effects and produce feedback events
// =============================================================================

namespace Automaton.Mvu;

/// <summary>
/// A render function that converts state into a view representation.
/// </summary>
/// <typeparam name="TState">The application state.</typeparam>
/// <typeparam name="TView">The view representation (e.g., Document, string, HTML).</typeparam>
public delegate TView Render<in TState, out TView>(TState state);

/// <summary>
/// Headless MVU runtime for testing and non-browser scenarios.
/// Runs the automaton loop: dispatch → transition → render → handle effects.
/// </summary>
/// <remarks>
/// <para>
/// Internally delegates to <see cref="AutomatonRuntime{TAutomaton,TState,TEvent,TEffect}"/>
/// with a render observer and the supplied interpreter.
/// </para>
/// <example>
/// <code>
/// var runtime = await MvuRuntime&lt;Counter, CounterState, CounterEvent, CounterEffect, string&gt;
///     .Start(
///         render: state =&gt; $"Count: {state.Count}",
///         interpreter: _ =&gt; Task.FromResult&lt;IEnumerable&lt;CounterEvent&gt;&gt;([]));
///
/// await runtime.Dispatch(new CounterEvent.Increment());
/// // runtime.State.Count == 1
/// // runtime.Views == ["Count: 0", "Count: 1"]
/// </code>
/// </example>
/// </remarks>
public sealed class MvuRuntime<TAutomaton, TState, TEvent, TEffect, TView>
    where TAutomaton : Automaton<TState, TEvent, TEffect>
{
    private readonly AutomatonRuntime<TAutomaton, TState, TEvent, TEffect> _core;
    private readonly List<TView> _views;

    /// <summary>
    /// The current state of the automaton.
    /// </summary>
    public TState State => _core.State;

    /// <summary>
    /// All views rendered during the lifetime of this runtime.
    /// </summary>
    public IReadOnlyList<TView> Views => _views;

    /// <summary>
    /// All events dispatched (including those generated by effects).
    /// </summary>
    public IReadOnlyList<TEvent> Events => _core.Events;

    private MvuRuntime(
        AutomatonRuntime<TAutomaton, TState, TEvent, TEffect> core,
        List<TView> views)
    {
        _core = core;
        _views = views;
    }

    /// <summary>
    /// Starts the MVU runtime, executing init and rendering the initial view.
    /// </summary>
    public static async Task<MvuRuntime<TAutomaton, TState, TEvent, TEffect, TView>> Start(
        Render<TState, TView> render,
        Interpreter<TEffect, TEvent> interpreter)
    {
        var (state, effect) = TAutomaton.Init();
        var views = new List<TView>();

        // Observer: render the new state after each transition
        Observer<TState, TEvent, TEffect> observer = (s, _, _) =>
        {
            views.Add(render(s));
            return Task.CompletedTask;
        };

        var core = new AutomatonRuntime<TAutomaton, TState, TEvent, TEffect>(
            state, observer, interpreter);

        // Render initial view (before effects, so the user sees something immediately)
        views.Add(render(state));

        // Handle init effects (may produce feedback events → more renders)
        await core.InterpretEffect(effect);

        return new MvuRuntime<TAutomaton, TState, TEvent, TEffect, TView>(core, views);
    }

    /// <summary>
    /// Dispatches an event into the MVU loop, triggering transition → render → effects.
    /// </summary>
    public async Task Dispatch(TEvent @event) =>
        await _core.Dispatch(@event);
}
