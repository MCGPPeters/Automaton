// =============================================================================
// MVU Runtime
// =============================================================================
// Model-View-Update as a specialization of the Automaton kernel.
//
// MVU extends the core automaton with:
// - A View function: State → Rendered output
// - Subscriptions: State → external event sources
//
// The runtime executes the loop: dispatch event → transition → view → effects.
// =============================================================================

namespace Automaton.Mvu;

/// <summary>
/// A render function that converts state into a view representation.
/// </summary>
/// <typeparam name="TState">The application state.</typeparam>
/// <typeparam name="TView">The view representation (e.g., Document, string, HTML).</typeparam>
public delegate TView Render<in TState, out TView>(TState state);

/// <summary>
/// Handles effects produced by the automaton's transition function.
/// Returns events to feed back into the loop (or empty for fire-and-forget effects).
/// </summary>
public delegate Task<IEnumerable<TEvent>> EffectHandler<TEffect, TEvent>(TEffect effect);

/// <summary>
/// Headless MVU runtime for testing and non-browser scenarios.
/// Runs the automaton loop: dispatch → transition → render → handle effects.
/// </summary>
/// <remarks>
/// <para>
/// This is a minimal in-memory runtime that proves the automaton kernel
/// supports the full MVU lifecycle without any browser or DOM dependency.
/// </para>
/// <example>
/// <code>
/// var runtime = await MvuRuntime&lt;Counter, CounterState, CounterEvent, CounterEffect, string&gt;
///     .Start(
///         render: state =&gt; $"Count: {state.Count}",
///         effectHandler: _ =&gt; Task.FromResult&lt;IEnumerable&lt;CounterEvent&gt;&gt;([]));
///
/// await runtime.Dispatch(new CounterEvent.Increment());
/// // runtime.State.Count == 1
/// // runtime.Views == ["Count: 0", "Count: 1"]
/// </code>
/// </example>
/// </remarks>
public sealed class MvuRuntime<TAutomaton, TState, TEvent, TEffect, TView>
    where TAutomaton : Automaton<TState, TEvent, TEffect>
{
    private TState _state;
    private readonly Render<TState, TView> _render;
    private readonly EffectHandler<TEffect, TEvent> _effectHandler;
    private readonly List<TView> _views = [];
    private readonly List<TEvent> _events = [];

    /// <summary>
    /// The current state of the automaton.
    /// </summary>
    public TState State => _state;

    /// <summary>
    /// All views rendered during the lifetime of this runtime.
    /// </summary>
    public IReadOnlyList<TView> Views => _views;

    /// <summary>
    /// All events dispatched (including those generated by effects).
    /// </summary>
    public IReadOnlyList<TEvent> Events => _events;

    private MvuRuntime(TState initialState, Render<TState, TView> render, EffectHandler<TEffect, TEvent> effectHandler)
    {
        _state = initialState;
        _render = render;
        _effectHandler = effectHandler;
    }

    /// <summary>
    /// Starts the MVU runtime, executing init and rendering the initial view.
    /// </summary>
    public static async Task<MvuRuntime<TAutomaton, TState, TEvent, TEffect, TView>> Start(
        Render<TState, TView> render,
        EffectHandler<TEffect, TEvent> effectHandler)
    {
        var (state, effect) = TAutomaton.Init();
        var runtime = new MvuRuntime<TAutomaton, TState, TEvent, TEffect, TView>(state, render, effectHandler);

        // Render initial view
        runtime._views.Add(render(state));

        // Handle init effects
        await runtime.HandleEffect(effect);

        return runtime;
    }

    /// <summary>
    /// Dispatches an event into the MVU loop, triggering transition → render → effects.
    /// </summary>
    public async Task Dispatch(TEvent @event)
    {
        _events.Add(@event);

        var (newState, effect) = TAutomaton.Transition(_state, @event);
        _state = newState;

        // Re-render after state change
        _views.Add(_render(_state));

        // Handle effects (may produce more events)
        await HandleEffect(effect);
    }

    private async Task HandleEffect(TEffect effect)
    {
        var resultEvents = await _effectHandler(effect);
        foreach (var resultEvent in resultEvents)
        {
            await Dispatch(resultEvent);
        }
    }
}
